---
title: "Toolbox Food Webs Analysis"
author: "Léo Ledru"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
bibliography: references.bib
params:
  lang: fr
---

# Introduction

This RMarkdown document is dedicated to the analysis of food webs, particularly the study of indirect effects between species within the network and the trophic cascade process.

-   <div>

    0.  Inférence de réseaux trophiques à partir de données (abondances, caractéristiques biologiques...) : Vagnon et al. 2021 (Ecosphere)

    </div>

-   <div>

    1.  **Mandatory :** [Loading food web and verifications](#loading_section)

    </div>

-   <div>

    2.  [Foodweb analysis: identification of trophic chains, calculation of trophic cascades, chain integration](#analysis_section)

    </div>

-   <div>

    3.  [Referencing indirect effects](#listing_indirect_section)

    </div>

-   <div>

    4.  [Graphic food web visualization](#visualization_section)

    </div>

-   <div>

    5.  [Visualization of trophic cascades with inversion](#inverted_cascade_section)

    </div>
    
-   <div>

    6.  [Stability and dynamics of food web](#stability_n_dynamics_section)

    </div>
        
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)

setwd("~/Documents/Post_Doc_CARRTEL/R/Toolbox")
#setwd("~/Documents/Post_Doc_CARRTEL-main/Toolbox_Foodwebs-main/")
library(rmarkdown)
library(shiny)
library(deSolve)
library(NetIndices) # to compute trophic levels and omnivory
library(sparsevar) # for spectralRadius function
library(expm) # for %^% operator
library(purrr) # is_empty function
library(rlist) # for list.reverse()
library(igraph) # to show food web as a graph
library(RColorBrewer)
library(scales)
library(ggplot2)
library(docstring) # allow to call the docstring of functions used in this RMarkdown as native R functions, by calling ?<functionName>
```

## <a name="foodweb_inference">Inference of food web from data (Vagnon et al. 2021)</a>

```{r}
# Main Code
# source("01_cv_Codes_AltitudeLakes.R")
# Functions used in the main code
# source("cv_Functions_AltitudeLakes.R")

```

## <a name="loading_section">Loading food web and verifications</a>

**This section must be run before any other sections below, as it involves loading the food web to be analyzed and checking its validity.**

The first necessary step is to load a food web in the form of an interaction matrix. This matrix must respect several properties:

-   It must be square, since the rows and columns correspond to the species in the food web.

-   All matrix elements must be numeric.

-   The species in rows and columns must be arranged in the same order, so that the diagonal of the matrix corresponds to self-regulation, i.e. the direct effect of a species on itself. All other elements $a_{ij}$ of the matrix correspond to the effect of species $j$ (in column) on species $i$ (in row).

-   The elements on the diagonal correspond to self-regulation: if they have been inferred, they must be $<0$; if not, they are set to $-1$, so that normalization by self-regulation to obtain the dimensionless matrix for calculating indirect effects [@zelnik2024] will not change the inferred interaction values.

-   The matrix must represent a food web, so every negative value must have a positive symmetrical value (although the positive value may be different, typically lower due to a conversion coefficient.

The following code block loads a test food web, then the ***CheckInit*** function performs a check on the interaction matrix, which must validate the aforementioned properties or an error message will be returned.

```{r}
# Load your food web

# Empirical test food web
# load("MyFoodWeb.Rdata")
# load("MyFoodWebLake.Rdata")
 load("LakesDirectSalmo.RData")
 MyFoodWeb <- LakesDirectSalmo[[2]]
 diag(MyFoodWeb) <- -1

# Simulated test food web
# load("StableFwbs_TL3.Rdata")
# MyFoodWeb <- StableFwbs_TL3[[5097]][["A"]]

CheckInit <- function(MyFoodWeb){
  if (!is.matrix(MyFoodWeb)){
    stop("Error: the variable is not a matrix")
  }
  if (!all(is.numeric(MyFoodWeb))){
    stop("Error: the matrix must contains numerics only")
  }
  if (nrow(MyFoodWeb) != ncol(MyFoodWeb)){
    stop("Error: the matrix is not square")
  }
  # No diagonal element can be empty, zero or positive
  for (element in diag(MyFoodWeb)) {
    if (is.na(element) || element == 0 || element > 0) {
      stop("Error: diagonal elements must be numeric < 0. Check the diagonal of the interaction matrix. If elements of the diagonal have not been inferred, set the value to -1.")
    }
  }
  # Verification of positive-negative symmetry (trophic links only)
  for (i in 1:nrow(MyFoodWeb)){
    for (j in 1:ncol(MyFoodWeb)){
      if (i != j){
        if ((MyFoodWeb[i, j] < 0 && MyFoodWeb[j, i] <= 0) || (MyFoodWeb[i, j] > 0 && MyFoodWeb[j, i] >= 0)){
          stop(paste("Error: Off-diagonal negative (positive) values must have a positive (negative) value at their symmetry. Problem with positions i =", i, "et j =", j))
        }
      }
    }
  }
  # Check for unconnected species: if they exist, remove them from the network
  FoodWebBis <- MyFoodWeb
  diag(FoodWebBis) <- 0 # remove self-reg to test if each species is connected with at least another one
  IdxUnconnected <- which(colSums(FoodWebBis) == 0)
  if (length(IdxUnconnected) > 0){
    MyFoodWeb <- MyFoodWeb[-IdxUnconnected,-IdxUnconnected]
    print(paste0("Species ", paste(IdxUnconnected, collapse = ", "), " are removed because unconnected"))
  }
  print("The food web is validated")
  return(MyFoodWeb)
}

#debug(CheckInit)
MyFoodWeb <- CheckInit(MyFoodWeb)
if (is.null(rownames(MyFoodWeb))){
  rownames(MyFoodWeb) <- 1:dim(MyFoodWeb)[[1]]
}
```

## <a name="analysis_section">Food web analysis: collectivity, connectivity, omnivory, trophic cascades, food chain integration</a>

This section calculates several proxies on the network and stores all the results in a list of lists called *FoodWebMetrics*. This list contains :

-   Collectivity [@zelnik2024]

-   Connectivity

-   Average omnivory

-   A sub-list with measures characterizing the trophic cascade process expressed by each trophic chain in the food web [@ledru2024] :

-   <div>

    -   *Top*: Predator index

    -   *Middle*: Consumer index

    -   *Bottom: Resource index*

    -   Value of short-term trophic cascade, i.e. the indirect effect from the *Top* to the *Bottom*

    -   Value of long-term trophic cascade, i.e. the net effect from *Top* to *Bottom*

    -   Long-term/short-term ratio showing whether there is a divergence between the two cascades.

    -   Value of the integration of the chain in the food web, i.e. the ratio between interactions within the chain and interactions between the chain and the rest of the food web, a proxy of the collectivity experienced by the trophic chain

    </div>

**NB**: Trophic chains are identified as follows; 1) calculation of the trophic level of each species, 2) identification of the maximum trophic level (must be at least 3) and the species with this level (the *Top*), 3) identification of species with a trophic level two levels below the maximum level (the *Bottom*), 4) identification of intermediate species link the *Top* and *Bottom* (the *Middle*). Thus, this analysis considers a trophic chain as running from the top of the food web to the top-2 level. If a food web has a maximum trophic level greater than 3, trophic chains will not go all the way down to the basal species.

```{r message=FALSE, warning=FALSE}

# Analysis of the food web
source("FoodWebAnalysis.R")
#debug(FoodWebAnalysis)
FoodWebMetrics <- FoodWebAnalysis(MyFoodWeb)
head(FoodWebMetrics)
```

## <a name="listing_indirect_section">Referencing indirect effects.</a>

Indirect effects can extend across the food web, potentially up to long order, connecting all species. This section calculates for each species with which it is connected for each order up to chosen maximum order. It also gives for each species the limit order (*OrderLim*) at which it has interacted with all others, considering the cumulative orders.

```{r}

SpNames <- paste(1:nrow(MyFoodWeb))
# Preallocate empty object
WhoWithWho <- vector("list", nrow(MyFoodWeb))
# Direct effect without self-reg
I <- diag(1, nrow = nrow(MyFoodWeb))
D <- diag(MyFoodWeb) # extract the self-regulation (diagonal)
MyFoodWeb <- MyFoodWeb / -D # normalize by self-regulation --> non-dimensional interaction matrix
DirectEffects <- MyFoodWeb + I # Extract the normalized self-regulation
MaxOrder <- 5
# ComputeLinks : for each species find all non-null interactions for each order until MaxOrder
# Also find the cumulative orderLim from which each species has interacted with all others
ComputeLinks <- function(i, DirectEffects, MaxOrder, SpNames){
  order <- 1
  InnerList <- list()
  A <- DirectEffects
  OrderLim <- NULL
  IdxCumul <- c()
  cond <- TRUE
  while(order <= MaxOrder){
    Idx <- which(A[,i] != 0)
    InnerList[[paste0("order", order)]] <- Idx
    IdxCumul <- c(IdxCumul, Idx)
    if (all(SpNames %in% IdxCumul) & cond){
      OrderLim <- order
      cond <- FALSE
    }
    order <- order + 1
    A <- DirectEffects%^%order
  }
  InnerList[["orderLim"]] <- OrderLim
  return(InnerList)
}
# Each outer list is a species, which contain as much inner lists as the chosen MaxOrder with the idx of species which who its interact for each, + the orderLim
WhoWithWho <- lapply(seq_along(WhoWithWho), function(i) ComputeLinks(i, DirectEffects, MaxOrder, SpNames))
SpNames <- rownames(MyFoodWeb)
names(WhoWithWho) <- SpNames

head(WhoWithWho)
```

## <a name="visualization_section">Graphic food web visualization</a> {data-link="<a name"}

A graphical visualization of the food web can provide an intuitive understanding of the relationships involved more easily than from the raw interaction matrix. This section provides this visualization in the form of nodes (species) connected by links (interactions).

Of course, for a food web, each link is bidirectional, meaning a positive effect of the prey on the predator in one direction and a negative effect of the predator on the prey in the other, but this subtlety is not represented and each prey-predator pair is simply connected by a link. On the other hand, the thickness of the link indicates the strength of the interaction.

The user can select a species of interest by its index in the interaction matrix via the *IdxFocusSpecies* parameter. In this case, the species' node will appear in green, the species' direct links will appear in red, as well as connected nodes, and in blue will be second-order links and connected species. This makes it easy to get an idea of the role the species of interest can play in the food web through its interactions with other species. To find out with whom the species of interest interacts for larger orders of indirect effects refer to the previous section.

```{r message=FALSE, warning=FALSE}

# Visualization
source("FoodWebGraph.R")
#debug(FoodWebGraph)
# IdxFocusSpecies = the numeric index of the chosen species if any
Graph <- FoodWebGraph(MyFoodWeb, IdxFocusSpecies = 1)

par(mar = c(1, 1, 1, 1)) # adjust margins
width <- 8  # Adjust the width to suit your needs
height <- 6  # Adjust the height to suit your needs
options(repr.plot.width = width, repr.plot.height = height)

scale <- 1 # to adjust edges thickness
plot(Graph, vertex.size = 8, vertex.color = V(Graph)$col,
    edge.width = as.numeric(E(Graph)$weight)*scale,
    edge.curved = 0.5, edge.color = E(Graph)$col)

# Add names of species for each node, if any
Names <- rownames(MyFoodWeb)
if (is.null(Names)){
  Names <- seq(1, nrow(MyFoodWeb))
}
text(x = max(par("usr")[1], par("usr")[2]) - 0.5, 
     y = seq(min(par("usr")[3], par("usr")[4]) + 0.1, 
             max(par("usr")[3], par("usr")[4]) - 0.1, 
             length.out = length(Names)),
     labels = paste(seq_along(Names), Names, sep = ". "), pos = 4, col = "black", cex = 1)

```

## <a name="inverted_cascade_section">Inverted chain</a>

The trophic cascade concept considers that the indirect effect of a predator in a trophic chain on the species two trophic levels lower in the trophic chain is positive, via its direct negative effect on the intermediate level. More generally, starting from a predator, its effect should be negative on lower trophic levels separated by an odd distance, and positive on levels separated by an even distance. For example, from a predator of trophic level 3 to a resource of trophic level 1, the distance being 2 links, the effect should be positive.

However, [@ledru2024] shows that in complex ecological networks it is no longer possible to consider trophic chains independently of each other. Indeed, multiple and potentially large indirect effects can disrupt the strictly top-down trophic cascade, so that the long-term trophic cascade, measured by the net effects between species, can be inverted in relation to the classic (short-term) trophic cascade.

The following code section identifies trophic chains likely to express an inverted trophic cascade and highlights them.

To see the precise value of each trophic cascade, refer to the *FoodWebMetrics* list calculated in the [Food web analysis section](#analysis_section).

```{r message=FALSE}

# Visualization of Inverted chain(s)
## outputs : a graph representing the food web, with links of inverted chain in colors (if any), all others links are black.
source("InvertedChainGraph.R")
# debug(InvertedChainGraph)
Outputs <- InvertedChainGraph(MyFoodWeb, FoodWebMetrics)
Graph <- Outputs[["Graph"]]
par(mar = c(1, 1, 1, 1)) # adjust margins
width <- 8  # Ajustez la largeur selon vos besoins
height <- 6  # Ajustez la hauteur selon vos besoins
options(repr.plot.width = width, repr.plot.height = height)

scale <- 0.5 # to adjust edges width
plot(Graph, vertex.size = 8, 
    edge.width = as.numeric(E(Graph)$weight)*scale,
    edge.curved = 0.5, edge.color = E(Graph)$col)

# Add names of species for each node, if any
Names <- rownames(MyFoodWeb)
if (is.null(Names)){
  Names <- seq(0, nrow(MyFoodWeb))
}
text(x = max(par("usr")[1], par("usr")[2]) - 0.5, 
     y = seq(min(par("usr")[3], par("usr")[4]) + 0.1, 
             max(par("usr")[3], par("usr")[4]) - 0.1, 
             length.out = length(Names)),
     labels = paste(seq_along(Names), Names, sep = ". "), pos = 4, col = "black", cex = 1)
# Warning : si plusieurs chaînes avec inversion ont un lien en commun une couleur va se superposer à l'autre
if (is.null(Outputs[["InvertedChains"]])){
  print("Aucune chaîne avec inversion de cascade")
}
  
# print(Outputs[["InvertedChains"]])
```

## \<a name="stability_n_dynamics_section">Stability and dynamics of food web</a>

### Visualizing the network in eigenvalue space

```{r message=FALSE, warning=FALSE}

# Compute eigen values, their barycentre and the collectivity
I <- diag(1, nrow = nrow(MyFoodWeb))
D <- diag(MyFoodWeb) # extract the self-regulation (diagonal)
MyFoodWeb <- MyFoodWeb / -D # normalize by self-regulation --> non-dimensional interaction matrix
DirectEffects <- MyFoodWeb + I # Extract the normalized self-regulation
ValuesVectors <- eigen(DirectEffects)
Values <- ValuesVectors[[1]]
Collect <- spectralRadius(DirectEffects)
Barycentre <- sum(Values) / length(Values)
# organize data
ValuesDf <- data.frame(Re = Re(Values), Im = Im(Values))
theta <- seq(0, 2 * pi, length.out = 100)
CollectCircle <- data.frame(Re = Re(Barycentre) + Collect * cos(theta),
                          Im = Im(Barycentre) + Collect * sin(theta))
ArrowData <- data.frame(
  x = c(Re(Barycentre), Re(Barycentre) + Collect * cos(pi/4)),
  y = c(Im(Barycentre), Im(Barycentre) + Collect * sin(pi/4))
)
# plot
ggplot(ValuesDf, aes(x = Re, y = Im)) +
  geom_point() +
  geom_vline(xintercept = 0) +
  geom_path(data = CollectCircle, aes(x = Re, y = Im), color = "black", linetype = "dashed") +
  geom_segment(data = ArrowData, 
               aes(x = x[1], y = y[1], xend = x[2], yend = y[2]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") +
  annotate("text", x = Re(Barycentre) + Collect * cos(pi/4)/2, 
           y = Im(Barycentre) + Collect * sin(pi/4)/2, label = "collectivity",
           angle = 29, hjust = 0, vjust = 1.3, fontface = "bold") +
  annotate("rect", xmin = 0, xmax = Inf, ymin = -Inf, ymax = Inf,
           alpha = .15, fill = "red") +
  annotate("text", x = Inf, y = Inf, label = "instability", hjust = 1.5, vjust = 1.5, fontface = "bold") +
  labs(x = "Real Part", y = "Imaginary Part") +
  ggtitle("Eigen values on complex space") +
  theme_minimal()
 
print(paste0("The maximum real part of eigen value is : ", max(ValuesDf$Re)))
```

### A proxy of stability

One estimate of stability, inspired by @neutel2002stability and @neutel2007reconciling, is to measure the minimum self-regulation (i.e. the value on the diagonal of the interaction matrix) required for the largest Real value of the matrix eigenvalues to be negative [@sauve2016plants]. **This is only a proxy for stability** based on the interaction matrix, since the true *Jacobian* matrix of the network would consist in applying the species densities to the interaction matrix. This method therefore amounts to measuring the minimum self-regulation for the network to be stable in the particular configuration where *all species have the same equilibrium density.*

**This proxy can be used to compare networks or to assess the impact of adding or removing a species from a network on its stability.**

```{r}
source("StabilityAlgorithm.R")
# debug(StabilityAlgorithm)
Value <- StabilityAlgorithm(MyFoodWeb, SelfRegInit = 0.1, Threshold = 10^-4)
cat("The minimum self-regulation (with the Threshold used) that must be applied to the","\n", "network for it to be stable is : ", Value)
```

### Food web dynamics

Food web dynamics can be simulated in a fairly general way using the Generalized Lotka-Volterra (GLV) model. The dynamics of each species depend on its intrinsic growth rate (positive or negative, depending on whether it is autotrophic or heterotrophic) and the sum of interactions with other species (the interaction matrix). 
The GLV therefore has just one parameter, the growth rate, which we break down into two: the GrowthRate of basal species and the DeathRate of non-basal species.

#### Simulation to equilibrium

The code section below tests whether, given the input parameters (growth rate and death rate), the system actually reaches a stable equilibrium without any extinction. If there are one or more extinctions, the species are removed and the simulation starts again, until a stable system is reached.
In the case of a simulated food web, this results in a stable configuration. In the case of an empirically inferred food web, which is suggested to be stable because it has been observed, the user can find the appropriate parameters to obtain a stable system without any extinction or species removal. These parameters can then be used in the next section.

```{r, message=FALSE, results='asis'}

# outputs : 1) temporal densities of the stable run after incremental removal of extinct species, if any, 2) the food web matrix, with rows and colums of extinct species removed, if any.
source("FoodWebEquilibrium.R")

# Set a new self-regulation if desired
# diag(MyFoodWeb) <- -1

# Run
Tmax <- 1000
Tstep <- 0.1
GrowthRate <- 0.15 # could be a vector if you want different growth rate for the different basal species (if so be careful to have a vector of the right length)
DeathRate <- 0.01 # could be a vector if you want different death rate for the different non-basal species (if so be careful to have a vector of the right length)

# debug(FoodWebEquilibrium)
Outputs <- FoodWebEquilibrium(MyFoodWeb, Tmax, Tstep, GrowthRate, DeathRate)

# Visualization
Dynamics <- Outputs[["Dynamics"]]
if (max(Dynamics$TrophLevel) == 3){
  colors <- c("darkgreen", "blue", "red")
}else{ # maximum trophic level = 4
  colors <- c("darkgreen", "blue", "red", "black")
} # you could create another vector of color if there is more trophic levels

DynamicsPlot <- ggplot(Dynamics) +
                geom_line(aes(x = Time, y = Density, color = factor(TrophLevel), group = factor(IdxSpecies)), linewidth = 1) +
                labs(title = paste0("Number of extinct species before stable configuration : ", Outputs[["NbrOfExtinct"]]), x = "Time", y = "Density", color = "Trophic levels") +
                scale_color_manual(values = colors) +
                theme_minimal()
DynamicsPlot # show plot
```

#### Food web disturbance

Once we have the configuration of the system at equilibrium (the species that persist and their density at equilibrium), we may want to see how the food web responds to the disturbance of one or more species. This allows us, for example, to directly visualize the dynamics of a cascade inversion potentially identified in the dedicated section.
This section of the code consists in choosing one or more species to be disturbed, i.e. whose growth/mortality rate will be modified, either positively or negatively. System dynamics in response to this disturbance are then simulated and plotted.

```{r}

source("FoodWebPerturb.R")
#debug(FoodWebPerturb)

# Set a self-regulation value if none inferred
# diag(MyFoodWeb) <- -1

# Run
Tmax <- 1000
Tstep <- 0.1
GrowthRate <- 0.1
DeathRate <- 0.01
Perturb <- 0.1
IdxPerturb <- 1 # Index of the species to perturb (or vector of indices for multiple species)
Dynamics <- FoodWebPerturb(MyFoodWeb, Tmax, Tstep, GrowthRate, DeathRate, IdxPerturb, Perturb, type = "Positive")

# Version with colors = each species
DynamicsPlot <- ggplot(Dynamics) +
                geom_line(aes(x = Time, y = Density, color = factor(IdxSpecies)), linewidth = 1) +
                geom_vline(xintercept = 2000) +
                labs(x = "Time", y = "Density", color = "Species") +
                theme_minimal()
DynamicsPlot # show plot

# Version with colors = trophic levels
if (max(Dynamics$TrophLevel) == 3){
  colors <- c("darkgreen", "blue", "red")
}else{ # maximum trophic level = 4
  colors <- c("darkgreen", "blue", "red", "black")
}
DynamicsPlot <- ggplot(Dynamics) +
                geom_line(aes(x = Time, y = Density, color = factor(TrophLevel), group = factor(IdxSpecies)), linewidth = 1) +
                geom_vline(xintercept = 2000, linewidth = 1.5) +
                scale_color_manual(values = colors) +
                labs(x = "Time", y = "Density", color = "Trophic levels") +
                theme_minimal()
DynamicsPlot # show plot
```
