---
title: "Toolbox Food Webs Analysis"
author: "Léo Ledru"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
# bibliography: references.bib
params:
  lang: fr
---

# Introduction

Ce document RMarkdown est dédié à l'analyse de réseaux trophiques, en particulier l'étude des effets indirects entre les espèces du réseau et le processus de cascade trophique.

-   <div>

    0.  Inférence de réseaux trophiques à partir de données (abondances, caractéristiques biologiques...) : Vagnon et al. 2021 (Ecosphere)

    </div>

<!-- -->

-   <div>

    1.  **Obligatoire :** [Loading food web and verifications](#loading_section)

    </div>

-   <div>

    2.  [Analyse du réseau (mesures de différents proxies)](#analysis_section)

    </div>

-   <div>

    3.  [Référencement des effets indirects](#listing_indirect_section)

    </div>

-   <div>

    4.  [Visualisation du réseau](#visualization_section)

    </div>

-   <div>

    5.  [Visualisation des inversions de cascades trophiques](#inverted_cascade_section)

    </div>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# setwd("~/Documents/Post_Doc_CARRTEL/R/Toolbox")
setwd("~/Documents/Post_Doc_CARRTEL-main/Toolbox_Foodwebs-main/")
library(rmarkdown)
library(shiny)
```

## <a name="foodweb_inference">Inference of food web from data (Vagnon et al. 2021)</a>

```{r}
# Main Code
# source("01_cv_Codes_AltitudeLakes.R")
# Functions used in the main code
# source("cv_Functions_AltitudeLakes.R")

```

## <a name="loading_section">Loading food web and verifications</a>

**This section must be run before any other section below.**

La première étape nécessaire est le chargement d'un réseau trophique sous la forme d'une matrice d'interaction. Cette matrice doit respectée plusieurs propriétés :

-   Elle doit être carrée puisque les lignes et les colonnes correspondent aux espèces du réseau.

-   Tous les éléments de la matrice doivent être des *numeric*.

-   Les espèces en lignes et en colonnes doivent être rangées dans le même ordre de sorte que la diagonale de la matrice correspond à la self-regulation, c'est-à-dire l'effet direct d'une espèce sur elle-même. Tandis que tous les autres éléments $a_ij$ de la matrice correspondent à l'effet de l'espèce $j$ (en colonne) sur l'espèce $i$ (en ligne).

-   Les éléments de la diagonale correspondent à la self-regulation : s'ils ont été inférés ils doivent bien être $<0$ ; sinon ils sont paramétrés à $-1$ comme cela la normalisation par la self-regulation permettant d'obtenir la matrice adimensionnelle pour le calcul des effets indirects [@zelnik2022collectively] ne changera pas les valeurs d'interactions inférées.

-   La matrice doit représenter un réseau purement trophique, donc chaque valeur négative doit avoir une symétrique positive (néanmoins la valeur positive peut être différente, typiquement plus faible à cause d'un coefficient de conversion).

Le bloc de code suivant charge un réseau de test, puis la fonction ***CheckInit*** procède à une vérification du réseau (de la matrice d'interaction) qui doit valider les propriétés précédemment citées sous peine de retourner un message d'erreur.

```{r}
# Load your food web

# Empirical test food web
#load("MyFoodWeb.Rdata")
# load("MyFoodWebLake.Rdata")

# Simulated test food web
load("StableFwbs_TL3.Rdata")
MyFoodWeb <- StableFwbs_TL3[[5097]][["A"]]

CheckInit <- function(MyFoodWeb){
  if (!is.matrix(MyFoodWeb)){
    stop("Erreur : la variable n'est pas une matrice")
  }
  if (!all(is.numeric(MyFoodWeb))){
    stop("Erreur : la matrice doit contenir uniquement des numeric")
  }
  if (nrow(MyFoodWeb) != ncol(MyFoodWeb)){
    stop("Erreur : la matrice n'est pas carrée")
  }
  # No diagonal element can be empty, zero or positive
  for (element in diag(MyFoodWeb)) {
    if (is.na(element) || element == 0 || element > 0) {
      stop("Erreur : les élements de la diagonales doivent être des numeric < 0. Veuillez vérifier la diagonale de la matrice d'interaction. Si des éléments de la diagonale n'ont pas inférés mettez une valeur de -1.")
    }
  }
  # Vérification de la symétrie positif-négatif (uniquement liens trophiques)
  for (i in 1:nrow(MyFoodWeb)){
    for (j in 1:ncol(MyFoodWeb)){
      if (i != j){
        if ((MyFoodWeb[i, j] < 0 && MyFoodWeb[j, i] <= 0) || (MyFoodWeb[i, j] > 0 && MyFoodWeb[j, i] >= 0)){
          stop(paste("Erreur : Les valeurs négatives (positives) hors-diagonale doivent avoir une valeur positive (négative) à leur symétrie. Problème avec les positions i =", i, "et j =", j))
        }
      }
    }
  }
  # Vérification de l'absence d'espèce non-connectée : si existence alors suppression du réseau
  FoodWebBis <- MyFoodWeb
  diag(FoodWebBis) <- 0 # remove self-reg to test if each species is connected with at least another one
  IdxUnconnected <- which(colSums(FoodWebBis) == 0)
  if (length(IdxUnconnected) > 0){
    MyFoodWeb <- MyFoodWeb[-IdxUnconnected,-IdxUnconnected]
    print(paste0("Species ", paste(IdxUnconnected, collapse = ", "), " are removed because unconnected"))
  }
  print("The food web is validated")
  return(MyFoodWeb)
}

#MyFoodWeb <- matrix(c(1,2,-3,1), nrow = 2, ncol = 2)
#debug(CheckInit)
MyFoodWeb <- CheckInit(MyFoodWeb)
```

## <a name="analysis_section">Analyse du réseau : collectivité, connectance, omnivorie, cascades trophiques, intégration des chaînes trophiques</a>

Cette section calcule plusieurs proxies sur le réseau et stocke l'ensemble des résultats dans une liste de listes nommée *FoodWebMetrics*. Cette liste contient :

-   La collectivité du réseau (Zelnik et al. 2024)

-   La connectance du réseau

-   L'omnivorie moyen du réseau (la moyenne de l'omnivorie de chaque espèce)

-   Une sous-liste comprenant pour chaque chaîne trophique du réseau :

-   <div>

    -   L'indice du prédateur (*Top*)

    -   L'indice du consommateur (*Middle*)

    -   L'indice de la ressource (*Bottom*)

    -   La valeur de la cascade trophique à court terme, c'est-à-dire l'effet indirect uniquement descendant du *Top* au *Bottom*

    -   La valeur de la cascade trophique à long terme, c'est-à-dire l'effet net du *Top* au *Bottom*

    -   Le ratio cascade trophique long terme / court terme montrant s'il y a une divergence entre les deux cascades (Ledru et al. 2024)

    -   La valeur d'intégration de la chaîne dans le réseau, qui correspond au ratio entre les interactions au sein de la chaîne et les interactions entre la chaîne et le reste du réseau, un proxy de la collectivité expériencée par la chaîne trophique (Ledru et al. 2024)

    </div>

**NB** : L'identification des chaînes trophiques se fait ainsi : 1) calcul du niveau trophique de chaque espèce, 2) identification du niveau trophique maximum (doit valoir au moins 3) et des espèces ayant ce niveau (les *Top*), 3) identification des espèces ayant un niveau trophique de deux crans inférieurs au niveau maximum (les *Bottom*), 4) identification des espèces intermédiaires reliant les *Top* et les *Bottom* (les *Middle*). Donc cette analyse considère une chaîne trophique comme partant du sommet du réseau jusqu'au niveau n-2. Dans le cas où un réseau a un niveau trophique maximum supérieur à 3 les chaînes trophiques ne descendront pas jusqu'aux espèces basales.

```{r message=FALSE}
library(NetIndices) # to compute trophic levels and omnivory
library(sparsevar) # for spectralRadius function
library(expm) # for %^% operator
library(purrr) # is_empty function
library(rlist) # for list.reverse()

# Analysis fo the food web
## outputs : a list with some food web metrics (collectivity, connectance, mean omnivory) and a dataframe listing all trophic chains within the food web (indices of species at the top, middle, and bottom of each chain), with their values of n-step cascade, net cascade, the ratio between the two cascades, and a measure of integration of the chain within the food web (interactions within the chain versus between the chain and the food web).
source("FoodWebAnalysis.R")
#debug(FoodWebAnalysis)
FoodWebMetrics <- FoodWebAnalysis(MyFoodWeb)
head(FoodWebMetrics)
```

## <a name="listing_indirect_section">Qui est relié avec qui, pour chaque ordre jusqu'à l'ordre maximal choisi.</a>

Les effets indirects peuvent s'étendre dans le réseau potentiellement jusqu'à de grands ordres jusqu'à connecter l'ensemble des espèces. Cette section calcule pour chaque espèce avec laquelle elle est connectée pour chaque ordre jusqu'à un ordre maximal choisi. De plus, donne également pour chacune *l'ordre limite* à partir duquel l'espèce a interragit avec toutes les autres en considérant les ordres cumulés.

```{r}

SpNames <- paste(1:nrow(MyFoodWeb))
# Créer un objet vide avec 10 lignes et 5 colonnes
WhoWithWho <- vector("list", nrow(MyFoodWeb))
# Direct effect without self-reg
I <- diag(1, nrow = nrow(MyFoodWeb))
D <- diag(MyFoodWeb) # extract the self-regulation (diagonal)
MyFoodWeb <- MyFoodWeb / -D # normalize by self-regulation --> non-dimensional interaction matrix
DirectEffects <- MyFoodWeb + I # Extract the normalized self-regulation
MaxOrder <- 5
# ComputeLinks : for each Sp find all non-null interactions for each order until MaxOrder
# Also find the cumulative orderLim from which each Sp has interacted with all others
ComputeLinks <- function(i, DirectEffects, MaxOrder, SpNames){
  order <- 1
  InnerList <- list()
  A <- DirectEffects
  OrderLim <- NULL
  IdxCumul <- c()
  cond <- TRUE
  while(order <= MaxOrder){
    Idx <- which(A[,i] != 0)
    InnerList[[paste0("order", order)]] <- Idx
    IdxCumul <- c(IdxCumul, Idx)
    if (all(SpNames %in% IdxCumul) & cond){
      OrderLim <- order
      cond <- FALSE
    }
    order <- order + 1
    A <- DirectEffects%^%order
  }
  InnerList[["orderLim"]] <- OrderLim
  return(InnerList)
}
# Each outer list is a species, which contain as much inner lists as the chosen MaxOrder with the idx of species which who its interact for each, + the orderLim
WhoWithWho <- lapply(seq_along(WhoWithWho), function(i) ComputeLinks(i, DirectEffects, MaxOrder, SpNames))
SpNames <- rownames(MyFoodWeb)
names(WhoWithWho) <- SpNames

head(WhoWithWho)
```

## <a name="visualization_section">Visualisation du réseau</a> {data-link="<a name=\"visualization_section\">Identification et visualisation des chaînes trophiques</a>"}

```{r message=FALSE, warning=FALSE}
library(igraph) # to show food web as a graph
library(RColorBrewer)

# Visualization
## outputs : a graph representing the food web, nodes are species and black curves are trophic links. If a focus species is chosen (IdxFocusSpecies = "the numeric index of the chosen species"), its direct links will show in red and its second-order links in blue.
source("FoodWebGraph.R")
#debug(FoodWebGraph)
Graph <- FoodWebGraph(MyFoodWeb, IdxFocusSpecies = 1)

par(mar = c(1, 1, 1, 1)) # adjust margins
width <- 8  # Ajustez la largeur selon vos besoins
height <- 6  # Ajustez la hauteur selon vos besoins
options(repr.plot.width = width, repr.plot.height = height)

scale <- 2 # to adjust edges width
plot(Graph, vertex.size = 8, 
    edge.width = as.numeric(E(Graph)$weight)*scale,
    edge.curved = 0.5, edge.color = E(Graph)$col)

# Add names of species for each node, if any
Names <- rownames(MyFoodWeb)
if (is.null(Names)){
  Names <- seq(1, nrow(MyFoodWeb))
}
text(x = max(par("usr")[1], par("usr")[2]) - 0.5, 
     y = seq(min(par("usr")[3], par("usr")[4]) + 0.1, 
             max(par("usr")[3], par("usr")[4]) - 0.1, 
             length.out = length(Names)),
     labels = paste(seq_along(Names), Names, sep = ". "), pos = 4, col = "black", cex = 1)

```

## <a name="inverted_cascade_section">Inverted chain</a>

```{r message=FALSE}
# Visualization of Inverted chain(s)
## outputs : a graph representing the food web, with links of inverted chain in colors (if any), all others links are black.
library("scales")
source("InvertedChainGraph.R")
# debug(InvertedChainGraph)
Outputs <- InvertedChainGraph(MyFoodWeb, FoodWebMetrics)
Graph <- Outputs[["Graph"]]
par(mar = c(1, 1, 1, 1)) # adjust margins
width <- 8  # Ajustez la largeur selon vos besoins
height <- 6  # Ajustez la hauteur selon vos besoins
options(repr.plot.width = width, repr.plot.height = height)

scale <- 1 # to adjust edges width
plot(Graph, vertex.size = 8, 
    edge.width = as.numeric(E(Graph)$weight)*scale,
    edge.curved = 0.5, edge.color = E(Graph)$col)

# Add names of species for each node, if any
Names <- rownames(MyFoodWeb)
if (is.null(Names)){
  Names <- seq(0, nrow(MyFoodWeb))
}
text(x = max(par("usr")[1], par("usr")[2]) - 0.5, 
     y = seq(min(par("usr")[3], par("usr")[4]) + 0.1, 
             max(par("usr")[3], par("usr")[4]) - 0.1, 
             length.out = length(Names)),
     labels = paste(seq_along(Names), Names, sep = ". "), pos = 4, col = "black", cex = 1)
# Warning : si plusieurs chaînes avec inversion ont un lien en commun une couleur va se superposer à l'autre
if (is.null(Outputs[["InvertedChains"]])){
  print("Aucune chaîne avec inversion de cascade")
}
  
# print(Outputs[["InvertedChains"]])
```

## Visualisation du réseau dans l'espace des valeurs propres

Calculer valeurs propres (avec self-reg normalisée extraite, donc diag = 0) et ploter l'espace des valeurs propres, faire apparaître la collectivité avec le cercle de rayon phi et faire apparaître la limite de stabilité sur l'axe de la partie réelle.

Également un algo pour estimer la self-reg minimale à appliquer pour "stabilité" ?

```{r message=FALSE, warning=FALSE}
library(ggplot2)

# Compute eigen values, their barycentre and the collectivity
I <- diag(1, nrow = nrow(MyFoodWeb))
D <- diag(MyFoodWeb) # extract the self-regulation (diagonal)
MyFoodWeb <- MyFoodWeb / -D # normalize by self-regulation --> non-dimensional interaction matrix
DirectEffects <- MyFoodWeb + I # Extract the normalized self-regulation
ValuesVectors <- eigen(DirectEffects)
Values <- ValuesVectors[[1]]
Collect <- spectralRadius(DirectEffects)
Barycentre <- sum(Values) / length(Values)
# organize data
ValuesDf <- data.frame(Re = Re(Values), Im = Im(Values))
theta <- seq(0, 2 * pi, length.out = 100)
CollectCircle <- data.frame(Re = Re(Barycentre) + Collect * cos(theta),
                          Im = Im(Barycentre) + Collect * sin(theta))
ArrowData <- data.frame(
  x = c(Re(Barycentre), Re(Barycentre) + Collect * cos(pi/4)),
  y = c(Im(Barycentre), Im(Barycentre) + Collect * sin(pi/4))
)
# plot
ggplot(ValuesDf, aes(x = Re, y = Im)) +
  geom_point() +
  geom_vline(xintercept = 0) +
  geom_path(data = CollectCircle, aes(x = Re, y = Im), color = "black", linetype = "dashed") +
  geom_segment(data = ArrowData, 
               aes(x = x[1], y = y[1], xend = x[2], yend = y[2]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") +
  annotate("text", x = Re(Barycentre) + Collect * cos(pi/4)/2, 
           y = Im(Barycentre) + Collect * sin(pi/4)/2, label = "collectivity",
           angle = 29, hjust = 0, vjust = 1.3, fontface = "bold") +
  annotate("rect", xmin = 0, xmax = Inf, ymin = -Inf, ymax = Inf,
           alpha = .15, fill = "red") +
  annotate("text", x = Inf, y = Inf, label = "instability", hjust = 1.5, vjust = 1.5, fontface = "bold") +
  labs(x = "Real Part", y = "Imaginary Part") +
  ggtitle("Eigen values on complex space") +
  theme_minimal()
 
print(paste0("The maximum real part of eigen value is : ", max(ValuesDf$Re)))
```

#### A proxy of stability

One estimate of stability, inspired by @neutel2002stability and @neutel2007reconciling, is to measure the minimum self-regulation (i.e. the value on the diagonal of the interaction matrix) required for the largest Real value of the matrix eigenvalues to be negative. **This is only a proxy for stability** based on the interaction matrix, since the true *Jacobian* matrix of the network would consist in applying the species densities to the interaction matrix. This method therefore amounts to measuring the minimum self-regulation for the network to be stable in the particular configuration where *all species have the same equilibrium density.*

**This proxy can be used to compare networks or to assess the impact of adding or removing a species from a network on its stability.**

```{r}
source("StabilityAlgorithm.R")
# debug(StabilityAlgorithm)
Value <- StabilityAlgorithm(MyFoodWeb, SelfRegInit = 0.1, Threshold = 10^-4)
print(paste0("The minimum self-regulation  (with the Threshold used) that must be applied to the network for it to be stable is : ", Value))


```

## Dynamique du réseau

### stabilité du réseau

Commence par tester si le réseau est stable : simulations successives en retirant les espèces éteintes à chaque fois tant qu'il y en a.

```{r, message=FALSE, results='asis'}
library(deSolve)

# Apply a Generalized Lotka-Volterra on the food web until a stable configuration (by removing extinct species) 
## outputs : 1) temporal densities of the stable run after incremental removal of extinct species, if any, 2) the food web matrix, with rows and colums of extinct species removed, if any.
source("FoodWebEquilibrium.R")

# Set a self-regulation value if none inferred
# diag(MyFoodWeb) <- -1

# Run
Tmax <- 1000
Tstep <- 0.1
GrowthRate <- 0.1
DeathRate <- 0.01
Outputs <- FoodWebEquilibrium(MyFoodWeb, Tmax, Tstep, GrowthRate, DeathRate)
# Visualization
Dynamics <- Outputs[["Dynamics"]]
if (max(Dynamics$TrophLevel) == 3){
  colors <- c("darkgreen", "blue", "red")
}else{ # maximum trophic level = 4
  colors <- c("darkgreen", "blue", "red", "black")
}
DynamicsPlot <- ggplot(Dynamics) +
                geom_line(aes(x = Time, y = Density, color = factor(TrophLevel), group = factor(IdxSpecies)), linewidth = 1) +
                labs(title = paste0("Number of extinct species before stable configuration : ", Outputs[["NbrOfExtinct"]]), x = "Time", y = "Density", color = "Trophic levels") +
                scale_color_manual(values = colors) +
                theme_minimal()
DynamicsPlot # show plot
```

### perturbation du réseau

Choisir une espèce à perturber et la valeur de perturbation ; simuler la dynamique et ploter ; différencier dans le plot l'espèce perturbé, ainsi que les espèces directement connectées à elles selon leur niveau troph, et les autres espèces en noir.

```{r}
source("FoodWebPerturb.R")
#debug(FoodWebPerturb)

# Set a self-regulation value if none inferred
# diag(MyFoodWeb) <- -1

# Run
Tmax <- 1000
Tstep <- 0.1
GrowthRate <- 0.1
DeathRate <- 0.01
Perturb <- 0.05
Dynamics <- FoodWebPerturb(MyFoodWeb, Tmax, Tstep, GrowthRate, DeathRate, 1, Perturb, type = "Positive")

# Version with colors = each species
DynamicsPlot <- ggplot(Dynamics) +
                geom_line(aes(x = Time, y = Density, color = factor(IdxSpecies)), linewidth = 1) +
                geom_vline(xintercept = 2000) +
                labs(x = "Time", y = "Density", color = "Species") +
                theme_minimal()
DynamicsPlot # show plot

# Version with colors = trophic levels
if (max(Dynamics$TrophLevel) == 3){
  colors <- c("darkgreen", "blue", "red")
}else{ # maximum trophic level = 4
  colors <- c("darkgreen", "blue", "red", "black")
}
DynamicsPlot <- ggplot(Dynamics) +
                geom_line(aes(x = Time, y = Density, color = factor(TrophLevel), group = factor(IdxSpecies)), linewidth = 1) +
                geom_vline(xintercept = 2000, linewidth = 1.5) +
                scale_color_manual(values = colors) +
                labs(x = "Time", y = "Density", color = "Trophic levels") +
                theme_minimal()
DynamicsPlot # show plot
```
