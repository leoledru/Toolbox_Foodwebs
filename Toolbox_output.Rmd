---
title: "Toolbox Food Webs Analysis"
author: "Léo Ledru"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
bibliography: references.bib
params:
  lang: fr
---

# Introduction

Ce document RMarkdown est dédié à l'analyse de réseaux trophiques, en particulier l'étude des effets indirects entre les espèces du réseau et le processus de cascade trophique.

-   <div>

    0.  Inférence de réseaux trophiques à partir de données (abondances, caractéristiques biologiques...) : Vagnon et al. 2021 (Ecosphere)

    </div>

-   <div>

    1.  **Obligatoire :** [Loading food web and verifications](#loading_section)

    </div>

-   <div>

    2.  [Analyse du réseau (mesures de différents proxies)](#analysis_section)

    </div>

-   <div>

    3.  [Référencement des effets indirects](#listing_indirect_section)

    </div>

-   <div>

    4.  [Visualisation du réseau](#visualization_section)

    </div>

-   <div>

    5.  [Visualisation des inversions de cascades trophiques](#inverted_cascade_section)

    </div>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Documents/Post_Doc_CARRTEL/R/Toolbox")
#setwd("~/Documents/Post_Doc_CARRTEL-main/Toolbox_Foodwebs-main/")
library(rmarkdown)
library(shiny)
library(deSolve)
library(NetIndices) # to compute trophic levels and omnivory
library(sparsevar) # for spectralRadius function
library(expm) # for %^% operator
library(purrr) # is_empty function
library(rlist) # for list.reverse()
library(igraph) # to show food web as a graph
library(RColorBrewer)
library(scales)
library(ggplot2)
```

## <a name="foodweb_inference">Inference of food web from data (Vagnon et al. 2021)</a>

```{r}
# Main Code
# source("01_cv_Codes_AltitudeLakes.R")
# Functions used in the main code
# source("cv_Functions_AltitudeLakes.R")

```

## <a name="loading_section">Loading food web and verifications</a>

**This section must be run before any other section below.**

La première étape nécessaire est le chargement d'un réseau trophique sous la forme d'une matrice d'interaction. Cette matrice doit respectée plusieurs propriétés :

-   Elle doit être carrée puisque les lignes et les colonnes correspondent aux espèces du réseau.

-   Tous les éléments de la matrice doivent être des *numeric*.

-   Les espèces en lignes et en colonnes doivent être rangées dans le même ordre de sorte que la diagonale de la matrice correspond à la self-regulation, c'est-à-dire l'effet direct d'une espèce sur elle-même. Tandis que tous les autres éléments $a_ij$ de la matrice correspondent à l'effet de l'espèce $j$ (en colonne) sur l'espèce $i$ (en ligne).

-   Les éléments de la diagonale correspondent à la self-regulation : s'ils ont été inférés ils doivent bien être $<0$ ; sinon ils sont paramétrés à $-1$ comme cela la normalisation par la self-regulation permettant d'obtenir la matrice adimensionnelle pour le calcul des effets indirects [@zelnik2024] ne changera pas les valeurs d'interactions inférées.

-   La matrice doit représenter un réseau purement trophique, donc chaque valeur négative doit avoir une symétrique positive (néanmoins la valeur positive peut être différente, typiquement plus faible à cause d'un coefficient de conversion).

Le bloc de code suivant charge un réseau de test, puis la fonction ***CheckInit*** procède à une vérification du réseau (de la matrice d'interaction) qui doit valider les propriétés précédemment citées sous peine de retourner un message d'erreur.

```{r}
# Load your food web

# Empirical test food web
# load("MyFoodWeb.Rdata")
# load("MyFoodWebLake.Rdata")
# load("LakesDirectSalmo.RData")
# MyFoodWeb <- LakesDirectSalmo[[1]]
# diag(MyFoodWeb) <- -1

# Simulated test food web
load("StableFwbs_TL3.Rdata")
MyFoodWeb <- StableFwbs_TL3[[5097]][["A"]]

CheckInit <- function(MyFoodWeb){
  if (!is.matrix(MyFoodWeb)){
    stop("Erreur : la variable n'est pas une matrice")
  }
  if (!all(is.numeric(MyFoodWeb))){
    stop("Erreur : la matrice doit contenir uniquement des numeric")
  }
  if (nrow(MyFoodWeb) != ncol(MyFoodWeb)){
    stop("Erreur : la matrice n'est pas carrée")
  }
  # No diagonal element can be empty, zero or positive
  for (element in diag(MyFoodWeb)) {
    if (is.na(element) || element == 0 || element > 0) {
      stop("Erreur : les élements de la diagonales doivent être des numeric < 0. Veuillez vérifier la diagonale de la matrice d'interaction. Si des éléments de la diagonale n'ont pas inférés mettez une valeur de -1.")
    }
  }
  # Vérification de la symétrie positif-négatif (uniquement liens trophiques)
  for (i in 1:nrow(MyFoodWeb)){
    for (j in 1:ncol(MyFoodWeb)){
      if (i != j){
        if ((MyFoodWeb[i, j] < 0 && MyFoodWeb[j, i] <= 0) || (MyFoodWeb[i, j] > 0 && MyFoodWeb[j, i] >= 0)){
          stop(paste("Erreur : Les valeurs négatives (positives) hors-diagonale doivent avoir une valeur positive (négative) à leur symétrie. Problème avec les positions i =", i, "et j =", j))
        }
      }
    }
  }
  # Vérification de l'absence d'espèce non-connectée : si existence alors suppression du réseau
  FoodWebBis <- MyFoodWeb
  diag(FoodWebBis) <- 0 # remove self-reg to test if each species is connected with at least another one
  IdxUnconnected <- which(colSums(FoodWebBis) == 0)
  if (length(IdxUnconnected) > 0){
    MyFoodWeb <- MyFoodWeb[-IdxUnconnected,-IdxUnconnected]
    print(paste0("Species ", paste(IdxUnconnected, collapse = ", "), " are removed because unconnected"))
  }
  print("The food web is validated")
  return(MyFoodWeb)
}

#MyFoodWeb <- matrix(c(1,2,-3,1), nrow = 2, ncol = 2)
#debug(CheckInit)
MyFoodWeb <- CheckInit(MyFoodWeb)
if (is.null(rownames(MyFoodWeb))){
  rownames(MyFoodWeb) <- 1:dim(MyFoodWeb)[[1]]
}
```

## <a name="analysis_section">Analyse du réseau : collectivité, connectance, omnivorie, cascades trophiques, intégration des chaînes trophiques</a>

Cette section calcule plusieurs proxies sur le réseau et stocke l'ensemble des résultats dans une liste de listes nommée *FoodWebMetrics*. Cette liste contient :

-   La collectivité du réseau [@zelnik2024]

-   La connectance du réseau

-   L'omnivorie moyen du réseau (la moyenne de l'omnivorie de chaque espèce)

-   Une sous-liste avec des mesures caractérisant le processus de cascade trophique exprimé par chaque chaîne trophique du réseau [@ledru2024] :

-   <div>

    -   L'indice du prédateur (*Top*)

    -   L'indice du consommateur (*Middle*)

    -   L'indice de la ressource (*Bottom*)

    -   La valeur de la cascade trophique à court terme, c'est-à-dire l'effet indirect uniquement descendant du *Top* au *Bottom*

    -   La valeur de la cascade trophique à long terme, c'est-à-dire l'effet net à long-terme du *Top* au *Bottom*

    -   Le ratio cascade trophique long terme / court terme montrant s'il y a une divergence entre les deux cascades

    -   La valeur d'intégration de la chaîne dans le réseau, qui correspond au ratio entre les interactions au sein de la chaîne et les interactions entre la chaîne et le reste du réseau, un proxy de la collectivité expériencée par la chaîne trophique

    </div>

**NB** : L'identification des **chaînes trophiques** se fait ainsi : 1) calcul du niveau trophique de chaque espèce, 2) identification du niveau trophique maximum (doit valoir au moins 3) et des espèces ayant ce niveau (les *Top*), 3) identification des espèces ayant un niveau trophique de deux crans inférieurs au niveau maximum (les *Bottom*), 4) identification des espèces intermédiaires reliant les *Top* et les *Bottom* (les *Middle*). Donc cette analyse considère une chaîne trophique comme partant du sommet du réseau jusqu'au niveau top-2. Dans le cas où un réseau a un niveau trophique maximum supérieur à 3 les chaînes trophiques ne descendront pas jusqu'aux espèces basales.

```{r message=FALSE, warning=FALSE}

# Analysis fo the food web
## outputs : a list with some food web metrics (collectivity, connectance, mean omnivory) and a dataframe listing all trophic chains within the food web (indices of species at the top, middle, and bottom of each chain), with their values of n-step cascade, net cascade, the ratio between the two cascades, and a measure of integration of the chain within the food web (interactions within the chain versus between the chain and the food web).
source("FoodWebAnalysis.R")
#debug(FoodWebAnalysis)
FoodWebMetrics <- FoodWebAnalysis(MyFoodWeb)
head(FoodWebMetrics)
```

## <a name="listing_indirect_section">Qui est relié avec qui, pour chaque ordre jusqu'à l'ordre maximal choisi.</a>

Les effets indirects peuvent s'étendre dans le réseau potentiellement jusqu'à de grands ordres jusqu'à connecter l'ensemble des espèces. Cette section calcule pour chaque espèce avec laquelle elle est connectée pour chaque ordre jusqu'à un ordre maximal choisi. De plus, donne également pour chacune *l'ordre limite* à partir duquel l'espèce a interragit avec toutes les autres en considérant les ordres cumulés.

```{r}

SpNames <- paste(1:nrow(MyFoodWeb))
# Créer un objet vide avec 10 lignes et 5 colonnes
WhoWithWho <- vector("list", nrow(MyFoodWeb))
# Direct effect without self-reg
I <- diag(1, nrow = nrow(MyFoodWeb))
D <- diag(MyFoodWeb) # extract the self-regulation (diagonal)
MyFoodWeb <- MyFoodWeb / -D # normalize by self-regulation --> non-dimensional interaction matrix
DirectEffects <- MyFoodWeb + I # Extract the normalized self-regulation
MaxOrder <- 5
# ComputeLinks : for each Sp find all non-null interactions for each order until MaxOrder
# Also find the cumulative orderLim from which each Sp has interacted with all others
ComputeLinks <- function(i, DirectEffects, MaxOrder, SpNames){
  order <- 1
  InnerList <- list()
  A <- DirectEffects
  OrderLim <- NULL
  IdxCumul <- c()
  cond <- TRUE
  while(order <= MaxOrder){
    Idx <- which(A[,i] != 0)
    InnerList[[paste0("order", order)]] <- Idx
    IdxCumul <- c(IdxCumul, Idx)
    if (all(SpNames %in% IdxCumul) & cond){
      OrderLim <- order
      cond <- FALSE
    }
    order <- order + 1
    A <- DirectEffects%^%order
  }
  InnerList[["orderLim"]] <- OrderLim
  return(InnerList)
}
# Each outer list is a species, which contain as much inner lists as the chosen MaxOrder with the idx of species which who its interact for each, + the orderLim
WhoWithWho <- lapply(seq_along(WhoWithWho), function(i) ComputeLinks(i, DirectEffects, MaxOrder, SpNames))
SpNames <- rownames(MyFoodWeb)
names(WhoWithWho) <- SpNames

head(WhoWithWho)
```

## <a name="visualization_section">Visualisation du réseau</a> {data-link="<a name=\"visualization_section\">Identification et visualisation des chaînes trophiques</a>"}

Une visualisation graphique du réseau peut permettre une compréhension intuitive des relations en jeu beaucoup plus facile qu'à partir de la matrice d'interactions brutes. Cette section permet cette visualisation sous forme de noeuds (les espèces) connectées par des liens (les interactions).

Bien sûr pour un réseau trophique chaque lien est bidirectionnel, signifiant un effet positif de la proie sur le prédateur dans un sens et un effet négatif du prédateur sur la proie dans l'autre sens, mais cette subtilité n'est pas representée et chaque couple proie-prédateur est simplement relié par un lien. En revanche, l'épaisseur du lien indique la force de l'interaction.

L'utilisateur peut choisir une espèce d'intérêt par son indice dans la matrice d'interaction, son numéro de ligne, via le paramètre *IdxFocusSpecies*. Dans ce cas les liens directs de cette espèce apparaitront en rouges, ainsi que les noeuds connectés, et en bleu seront les liens d'ordre deux ainsi que les espèces connectées. Cela permet d'avoir facilement une idée du rôle que peut jouer l'espèce d'intérêt dans le réseau via ses interactions avec les autres espèces. Pour savoir avec qui l'espèce d'intérêt interagit pour des ordres d'effets indirects plus grand se référer à la section précédente.

```{r message=FALSE, warning=FALSE}

# Visualization
## outputs : a graph representing the food web, nodes are species and black curves are trophic links. If a focus species is chosen (IdxFocusSpecies = "the numeric index of the chosen species"), its direct links will show in red and its second-order links in blue.
source("FoodWebGraph.R")
#debug(FoodWebGraph)
Graph <- FoodWebGraph(MyFoodWeb, IdxFocusSpecies = 1)

par(mar = c(1, 1, 1, 1)) # adjust margins
width <- 8  # Ajustez la largeur selon vos besoins
height <- 6  # Ajustez la hauteur selon vos besoins
options(repr.plot.width = width, repr.plot.height = height)

scale <- 1 # to adjust edges width
plot(Graph, vertex.size = 8, vertex.color = V(Graph)$col,
    edge.width = as.numeric(E(Graph)$weight)*scale,
    edge.curved = 0.5, edge.color = E(Graph)$col)

# Add names of species for each node, if any
Names <- rownames(MyFoodWeb)
if (is.null(Names)){
  Names <- seq(1, nrow(MyFoodWeb))
}
text(x = max(par("usr")[1], par("usr")[2]) - 0.5, 
     y = seq(min(par("usr")[3], par("usr")[4]) + 0.1, 
             max(par("usr")[3], par("usr")[4]) - 0.1, 
             length.out = length(Names)),
     labels = paste(seq_along(Names), Names, sep = ". "), pos = 4, col = "black", cex = 1)

```

## <a name="inverted_cascade_section">Inverted chain</a>

Le concept de cascade trophique considère que l'effet indirect d'un prédateur d'une chaîne trophique sur l'espèce deux niveaux trophiques plus bas dans la chaîne trophique est positif, via son effet direct négatif sur le niveau intermédiaire. Plus généralement, partant d'un prédateur, son effet devrait être négatif sur les niveaux trophiques inférieurs impair et positif sur les niveaux séparés d'une distance paire. Par exemple d'un prédateur de niveau trophique 3 à une ressource de niveau trophique 1 la distance étant de 2 liens l'effet devrait être positif.

Cependant, Ledru et al. 2024 montre que dans des réseaux écologiques complexes il n'est plus possible de considérer les chaînes trophiques indépendamment les unes des autres. En effet, des effets indirects multiples et potentiellement d'ordres importants peuvent perturber la cascade trophique strictement descendante, de telle sorte que la cascade trophique à long-terme, mesurée par les effets nets entre les espèces, peut être inversée par rapport à la cascade trophique classique (à court-terme).

La section de code suivante identifie les chaînes trophiques susceptibles d'exprimer une cascade trophique inversée et les mets en lumière.

Pour voir précisément la *valeur* de chaque cascade trophique se référer à la liste **FoodWebMetrics** calculée dans la section [Analyse du réseau](#analysis_section).

```{r message=FALSE}

# Visualization of Inverted chain(s)
## outputs : a graph representing the food web, with links of inverted chain in colors (if any), all others links are black.
source("InvertedChainGraph.R")
# debug(InvertedChainGraph)
Outputs <- InvertedChainGraph(MyFoodWeb, FoodWebMetrics)
Graph <- Outputs[["Graph"]]
par(mar = c(1, 1, 1, 1)) # adjust margins
width <- 8  # Ajustez la largeur selon vos besoins
height <- 6  # Ajustez la hauteur selon vos besoins
options(repr.plot.width = width, repr.plot.height = height)

scale <- 0.5 # to adjust edges width
plot(Graph, vertex.size = 8, 
    edge.width = as.numeric(E(Graph)$weight)*scale,
    edge.curved = 0.5, edge.color = E(Graph)$col)

# Add names of species for each node, if any
Names <- rownames(MyFoodWeb)
if (is.null(Names)){
  Names <- seq(0, nrow(MyFoodWeb))
}
text(x = max(par("usr")[1], par("usr")[2]) - 0.5, 
     y = seq(min(par("usr")[3], par("usr")[4]) + 0.1, 
             max(par("usr")[3], par("usr")[4]) - 0.1, 
             length.out = length(Names)),
     labels = paste(seq_along(Names), Names, sep = ". "), pos = 4, col = "black", cex = 1)
# Warning : si plusieurs chaînes avec inversion ont un lien en commun une couleur va se superposer à l'autre
if (is.null(Outputs[["InvertedChains"]])){
  print("Aucune chaîne avec inversion de cascade")
}
  
# print(Outputs[["InvertedChains"]])
```

## Visualisation du réseau dans l'espace des valeurs propres

```{r message=FALSE, warning=FALSE}

# Compute eigen values, their barycentre and the collectivity
I <- diag(1, nrow = nrow(MyFoodWeb))
D <- diag(MyFoodWeb) # extract the self-regulation (diagonal)
MyFoodWeb <- MyFoodWeb / -D # normalize by self-regulation --> non-dimensional interaction matrix
DirectEffects <- MyFoodWeb + I # Extract the normalized self-regulation
ValuesVectors <- eigen(DirectEffects)
Values <- ValuesVectors[[1]]
Collect <- spectralRadius(DirectEffects)
Barycentre <- sum(Values) / length(Values)
# organize data
ValuesDf <- data.frame(Re = Re(Values), Im = Im(Values))
theta <- seq(0, 2 * pi, length.out = 100)
CollectCircle <- data.frame(Re = Re(Barycentre) + Collect * cos(theta),
                          Im = Im(Barycentre) + Collect * sin(theta))
ArrowData <- data.frame(
  x = c(Re(Barycentre), Re(Barycentre) + Collect * cos(pi/4)),
  y = c(Im(Barycentre), Im(Barycentre) + Collect * sin(pi/4))
)
# plot
ggplot(ValuesDf, aes(x = Re, y = Im)) +
  geom_point() +
  geom_vline(xintercept = 0) +
  geom_path(data = CollectCircle, aes(x = Re, y = Im), color = "black", linetype = "dashed") +
  geom_segment(data = ArrowData, 
               aes(x = x[1], y = y[1], xend = x[2], yend = y[2]),
               arrow = arrow(length = unit(0.2, "inches")), color = "black") +
  annotate("text", x = Re(Barycentre) + Collect * cos(pi/4)/2, 
           y = Im(Barycentre) + Collect * sin(pi/4)/2, label = "collectivity",
           angle = 29, hjust = 0, vjust = 1.3, fontface = "bold") +
  annotate("rect", xmin = 0, xmax = Inf, ymin = -Inf, ymax = Inf,
           alpha = .15, fill = "red") +
  annotate("text", x = Inf, y = Inf, label = "instability", hjust = 1.5, vjust = 1.5, fontface = "bold") +
  labs(x = "Real Part", y = "Imaginary Part") +
  ggtitle("Eigen values on complex space") +
  theme_minimal()
 
print(paste0("The maximum real part of eigen value is : ", max(ValuesDf$Re)))
```

#### A proxy of stability

One estimate of stability, inspired by @neutel2002stability and @neutel2007reconciling, is to measure the minimum self-regulation (i.e. the value on the diagonal of the interaction matrix) required for the largest Real value of the matrix eigenvalues to be negative. **This is only a proxy for stability** based on the interaction matrix, since the true *Jacobian* matrix of the network would consist in applying the species densities to the interaction matrix. This method therefore amounts to measuring the minimum self-regulation for the network to be stable in the particular configuration where *all species have the same equilibrium density.*

**This proxy can be used to compare networks or to assess the impact of adding or removing a species from a network on its stability.**

```{r}

source("StabilityAlgorithm.R")
# debug(StabilityAlgorithm)
Value <- StabilityAlgorithm(MyFoodWeb, SelfRegInit = 0.1, Threshold = 10^-4)
print(paste0("The minimum self-regulation  (with the Threshold used) that must be applied to the network for it to be stable is : ", Value))


```

## Dynamique du réseau

Cette section applique un modèle de Lotka-Volterra Généralisé (GLV) sur la matrice d'interactions du réseau pour simuler sa dynamique.

### Stabilité du réseau

Le GLV n'a que deux paramètres : le GrowthRate des espèces basales et le DeathRate des espèces non-basales.

La section de code ci-dessous teste si en fonction des paramètres donnés en entrée le système atteint effectivement un équilibre stable sans aucune extinction. S'il y a une ou plusieurs extinctions les espèces sont retirées et la simulation recommence, cela jusqu'à atteindre un système stable.

Cela permet dans le cas d'un réseau simulé d'obtenir une configuration stable. Dans le cas d'un réseau inféré empiriquement, et donc qu'on suggère stable puisque observé, l'utilisateur peut trouver les paramètres adéquates pour avoir un système stable sans aucune extinction ni retrait d'espèce. Il pourra ensuite utiliser ces paramètres pour la section suivante.

```{r, message=FALSE, results='asis'}

# Apply a Generalized Lotka-Volterra on the food web until a stable configuration (by removing extinct species) 
## outputs : 1) temporal densities of the stable run after incremental removal of extinct species, if any, 2) the food web matrix, with rows and colums of extinct species removed, if any.
source("FoodWebEquilibrium.R")

# Set a new self-regulation if desired
# diag(MyFoodWeb) <- -1

# Run
Tmax <- 1000
Tstep <- 0.1
GrowthRate <- 0.15
DeathRate <- 0.01
# debug(FoodWebEquilibrium)
Outputs <- FoodWebEquilibrium(MyFoodWeb, Tmax, Tstep, GrowthRate, DeathRate)
# Visualization
Dynamics <- Outputs[["Dynamics"]]
if (max(Dynamics$TrophLevel) == 3){
  colors <- c("darkgreen", "blue", "red")
}else{ # maximum trophic level = 4
  colors <- c("darkgreen", "blue", "red", "black")
}
DynamicsPlot <- ggplot(Dynamics) +
                geom_line(aes(x = Time, y = Density, color = factor(TrophLevel), group = factor(IdxSpecies)), linewidth = 1) +
                labs(title = paste0("Number of extinct species before stable configuration : ", Outputs[["NbrOfExtinct"]]), x = "Time", y = "Density", color = "Trophic levels") +
                scale_color_manual(values = colors) +
                theme_minimal()
DynamicsPlot # show plot
```

### Perturbation du réseau

Choisir une espèce à perturber et la valeur de perturbation ; simuler la dynamique et ploter ; différencier dans le plot l'espèce perturbé, ainsi que les espèces directement connectées à elles selon leur niveau troph, et les autres espèces en noir.

```{r}

source("FoodWebPerturb.R")
#debug(FoodWebPerturb)

# Set a self-regulation value if none inferred
# diag(MyFoodWeb) <- -1

# Run
Tmax <- 1000
Tstep <- 0.1
GrowthRate <- 0.1
DeathRate <- 0.01
Perturb <- 0.1
IdxPerturb <- 1 # Index of the species to perturb (or vector of indices for multiple species)
Dynamics <- FoodWebPerturb(MyFoodWeb, Tmax, Tstep, GrowthRate, DeathRate, IdxPerturb, Perturb, type = "Positive")

# Version with colors = each species
DynamicsPlot <- ggplot(Dynamics) +
                geom_line(aes(x = Time, y = Density, color = factor(IdxSpecies)), linewidth = 1) +
                geom_vline(xintercept = 2000) +
                labs(x = "Time", y = "Density", color = "Species") +
                theme_minimal()
DynamicsPlot # show plot

# Version with colors = trophic levels
if (max(Dynamics$TrophLevel) == 3){
  colors <- c("darkgreen", "blue", "red")
}else{ # maximum trophic level = 4
  colors <- c("darkgreen", "blue", "red", "black")
}
DynamicsPlot <- ggplot(Dynamics) +
                geom_line(aes(x = Time, y = Density, color = factor(TrophLevel), group = factor(IdxSpecies)), linewidth = 1) +
                geom_vline(xintercept = 2000, linewidth = 1.5) +
                scale_color_manual(values = colors) +
                labs(x = "Time", y = "Density", color = "Trophic levels") +
                theme_minimal()
DynamicsPlot # show plot
```
